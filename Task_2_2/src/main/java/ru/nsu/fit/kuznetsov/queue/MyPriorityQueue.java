/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package ru.nsu.fit.kuznetsov.queue;

import java.util.*;
import java.util.function.*;
import java.util.stream.*;

/**
 * This class allows us to use Priority Queue.
 *
 * @param <K> the type of keys
 * @param <V> the type of values
 */
public class MyPriorityQueue<K extends Comparable<K>, V> implements Iterable<V> {
  LinkedList<Map.Entry<K, V>> queue;

  /** This class implements iterator for MyPriorityQueue. */
  public class QueueIterator implements Iterator<V> {

    Iterator<Map.Entry<K, V>> iterator;

    public QueueIterator() {
      iterator = queue.iterator();
    }

    @Override
    public boolean hasNext() {
      return iterator.hasNext();
    }

    @Override
    public V next() {
      Map.Entry<K, V> elem = iterator.next();
      return elem.getValue();
    }
  }

  /**
   * This class implements all methods from interface Stream without methods connected with
   * parallelism.
   *
   * @param <T>
   */
  public class MyStream<T> implements Stream<T> {

    List<T> streamContent;

    class Builder<E> implements Stream.Builder<E> {

      ArrayList<E> streamContent;

      public Builder() {
        this.streamContent = new ArrayList<E>();
      }

      @Override
      public void accept(E kvEntry) {
        if (streamContent == null) {
          throw new IllegalStateException();
        }
        streamContent.add(kvEntry);
      }

      @Override
      public Stream<E> build() {
        ArrayList<E> copy = streamContent;
        streamContent = null;
        return new MyStream<E>(copy);
      }
    }

    public MyStream(List<T> input) {
      this.streamContent = input;
    }

    @Override
    public Stream<T> filter(Predicate<? super T> predicate) {
      Builder<T> builder = new Builder<T>();
      for (T elem : streamContent) {
        if (predicate.test(elem)) {
          builder.accept(elem);
        }
      }
      return builder.build();
    }

    @Override
    public <R> Stream<R> map(Function<? super T, ? extends R> mapper) {
      Builder<R> builder = new Builder<R>();
      for (T elem : streamContent) {
        builder.accept(mapper.apply(elem));
      }
      return builder.build();
    }

    @Override
    public IntStream mapToInt(ToIntFunction<? super T> mapper) {
      return streamContent.stream().mapToInt(mapper);
    }

    @Override
    public LongStream mapToLong(ToLongFunction<? super T> mapper) {
      return streamContent.stream().mapToLong(mapper);
    }

    @Override
    public DoubleStream mapToDouble(ToDoubleFunction<? super T> mapper) {
      return streamContent.stream().mapToDouble(mapper);
    }

    public <R> Stream<R> flatMap(Function<? super T, ? extends Stream<? extends R>> mapper) {
      Builder<R> builder = new Builder<R>();
      for (T elem : streamContent) {
        mapper.apply(elem).peek(builder);
      }
      return builder.build();
    }

    @Override
    public IntStream flatMapToInt(Function<? super T, ? extends IntStream> mapper) {
      return streamContent.stream().flatMapToInt(mapper);
    }

    @Override
    public LongStream flatMapToLong(Function<? super T, ? extends LongStream> mapper) {
      return streamContent.stream().flatMapToLong(mapper);
    }

    @Override
    public DoubleStream flatMapToDouble(Function<? super T, ? extends DoubleStream> mapper) {
      return streamContent.stream().flatMapToDouble(mapper);
    }

    @Override
    public Stream<T> distinct() {
      Builder<T> builder = new Builder<T>();
      Set<T> checkSet = new HashSet<>();
      for (T elem : streamContent) {
        if (!checkSet.contains(elem)) {
          checkSet.add(elem);
          builder.accept(elem);
        }
      }
      return builder.build();
    }

    @Override
    public Stream<T> sorted() {
      Builder<T> builder = new Builder<T>();
      if (streamContent.isEmpty()) {
        return builder.build();
      }
      streamContent.sort(
          new Comparator<T>() {
            @Override
            @SuppressWarnings("unchecked")
            public int compare(T o1, T o2) {
              return ((Comparable<T>) o1).compareTo(o2);
            }
          });
      return new MyStream<>(streamContent);
    }

    @Override
    public Stream<T> sorted(Comparator<? super T> comparator) {
      Builder<T> builder = new Builder<T>();
      streamContent.sort(comparator);
      for (T elem : streamContent) {
        builder.accept(elem);
      }
      return builder.build();
    }

    @Override
    public Stream<T> peek(Consumer<? super T> action) {
      Builder<T> builder = new Builder<T>();
      for (T elem : streamContent) {
        action.accept(elem);
        builder.accept(elem);
      }
      return builder.build();
    }

    @Override
    public Stream<T> limit(long maxSize) {
      if (maxSize < 0) {
        throw new IllegalArgumentException();
      }
      Builder<T> builder = new Builder<T>();
      long count = 0;
      for (T elem : streamContent) {
        count++;
        if (count > maxSize) {
          break;
        }
        builder.accept(elem);
      }
      return builder.build();
    }

    @Override
    public Stream<T> skip(long n) {
      if (n < 0) {
        throw new IllegalArgumentException();
      }
      Builder<T> builder = new Builder<T>();
      if (streamContent.size() < n) {
        return builder.build();
      }
      int count = 0;
      for (T elem : streamContent) {
        if (count != n) {
          count++;
          continue;
        }
        builder.accept(elem);
      }
      return builder.build();
    }

    @Override
    public void forEach(Consumer<? super T> action) {
      for (T elem : streamContent) {
        action.accept(elem);
      }
    }

    @Override
    public void forEachOrdered(Consumer<? super T> action) {
      for (T elem : streamContent) {
        action.accept(elem);
      }
    }

    @Override
    public Object[] toArray() {
      int len = streamContent.size();
      Object[] arr = new Object[len];
      ListIterator<T> iterator = streamContent.listIterator();
      for (int i = 0; i < len; i++) {
        arr[i] = iterator.next();
      }
      return arr;
    }

    @Override
    public <A> A[] toArray(IntFunction<A[]> generator) {
      int len = streamContent.size();
      A[] arr = generator.apply(len);
      ListIterator<T> iterator = streamContent.listIterator();
      for (int i = 0; i < len; i++) {
        try {
          arr[i] = (A) iterator.next();
        } catch (ClassCastException ignore) {
          throw new ArrayStoreException();
        }
      }
      return arr;
    }

    @Override
    public T reduce(T identity, BinaryOperator<T> accumulator) {
      T result = identity;
      for (T elem : streamContent) result = accumulator.apply(result, elem);
      return result;
    }

    @Override
    public Optional<T> reduce(BinaryOperator<T> accumulator) {
      boolean foundAny = false;
      T result = null;
      for (T elem : streamContent) {
        if (!foundAny) {
          foundAny = true;
          result = elem;
        } else result = accumulator.apply(result, elem);
      }
      return foundAny ? Optional.of(result) : Optional.empty();
    }

    @Override
    public <U> U reduce(
        U identity, BiFunction<U, ? super T, U> accumulator, BinaryOperator<U> combiner) {
      return streamContent.stream().reduce(identity, accumulator, combiner);
    }

    @Override
    public <R> R collect(
        Supplier<R> supplier, BiConsumer<R, ? super T> accumulator, BiConsumer<R, R> combiner) {
      R supplierResult = supplier.get();
      for (T elem : streamContent) {
        accumulator.accept(supplierResult, elem);
      }
      return supplierResult;
    }

    @Override
    public <R, A> R collect(Collector<? super T, A, R> collector) {
      A supplierResult = collector.supplier().get();
      for (T elem : streamContent) {
        collector.accumulator().accept(supplierResult, elem);
      }
      return collector.finisher().apply(supplierResult);
    }

    @Override
    public Optional<T> min(Comparator<? super T> comparator) {
      if (streamContent.isEmpty()) {
        return Optional.empty();
      }
      ListIterator<T> iterator = streamContent.listIterator();
      T min = iterator.next();
      while (iterator.hasNext()) {
        T elem = iterator.next();
        if (comparator.compare(elem, min) < 0) {
          min = elem;
        }
      }
      return Optional.of(min);
    }

    @Override
    public Optional<T> max(Comparator<? super T> comparator) {
      if (streamContent.isEmpty()) {
        return Optional.empty();
      }
      ListIterator<T> iterator = streamContent.listIterator();
      T max = iterator.next();
      while (iterator.hasNext()) {
        T elem = iterator.next();
        if (comparator.compare(elem, max) > 0) {
          max = elem;
        }
      }
      return Optional.of(max);
    }

    @Override
    public long count() {
      return streamContent.size();
    }

    @Override
    public boolean anyMatch(Predicate<? super T> predicate) {
      if (streamContent.size() == 0) {
        return false;
      }
      for (T elem : streamContent) {
        if (predicate.test(elem)) {
          return true;
        }
      }
      return false;
    }

    @Override
    public boolean allMatch(Predicate<? super T> predicate) {
      if (streamContent.size() == 0) {
        return true;
      }
      boolean isAllMatch = true;
      for (T elem : streamContent) {
        if (!predicate.test(elem)) {
          isAllMatch = false;
        }
      }
      return isAllMatch;
    }

    @Override
    public boolean noneMatch(Predicate<? super T> predicate) {
      if (streamContent.size() == 0) {
        return true;
      }
      boolean isNoneMatch = true;
      for (T elem : streamContent) {
        if (predicate.test(elem)) {
          isNoneMatch = false;
        }
      }
      return isNoneMatch;
    }

    @Override
    public Optional<T> findFirst() {
      if (streamContent.size() == 0) {
        return Optional.empty();
      }
      ListIterator<T> iterator = streamContent.listIterator();
      T first = iterator.next();
      return Optional.of(first);
    }

    @Override
    public Optional<T> findAny() {
      int size = streamContent.size();
      if (size == 0) {
        return Optional.empty();
      }
      int idx = streamContent.get(0).hashCode() % size;
      T elem = streamContent.get(idx);
      if (elem == null) {
        throw new NullPointerException();
      }
      return Optional.of(elem);
    }

    @Override
    public Iterator<T> iterator() {
      return streamContent.listIterator();
    }

    @Override
    public Spliterator<T> spliterator() {
      return streamContent.spliterator();
    }

    @Override
    public boolean isParallel() {
      return streamContent.stream().isParallel();
    }

    @Override
    public Stream<T> sequential() {
      return streamContent.stream().sequential();
    }

    @Override
    public Stream<T> parallel() {
      return streamContent.stream().parallel();
    }

    @Override
    public Stream<T> unordered() {
      return streamContent.stream().unordered();
    }

    @Override
    public Stream<T> onClose(Runnable closeHandler) {
      return streamContent.stream().onClose(closeHandler);
    }

    @Override
    public void close() {
      streamContent.stream().close();
    }
  }

  @Override
  public Iterator<V> iterator() {
    return new QueueIterator();
  }

  /**
   * Adds new pair of key and value to the queue
   *
   * @param key the key to be added
   * @param value the value to be added
   */
  public void insert(K key, V value) {
    ListIterator<Map.Entry<K, V>> iterator = queue.listIterator();
    while (iterator.hasNext()) {
      Map.Entry<K, V> e = iterator.next();
      if (e.getKey().compareTo(key) <= 0) {
        iterator.previous();
        break;
      }
    }
    iterator.add(new AbstractMap.SimpleEntry<>(key, value));
  }

  /**
   * Removes the element with the max key from queue
   *
   * @return the value which has the max key
   */
  public V extractMax() {
    Map.Entry<K, V> e = queue.remove();
    return e.getValue();
  }

  /**
   * Creates the Stream for the queue
   *
   * @return the stream
   */
  public Stream<Map.Entry<K, V>> stream() {
    return new MyStream(new LinkedList(queue));
  }

  /** Creates new queue */
  public MyPriorityQueue() {
    this.queue = new LinkedList<>();
  }
}
